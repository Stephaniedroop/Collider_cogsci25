#################################################### 
###########  Collider ppt data preprocessing  #############
####################################################

# Script for putting together the batches of participants, data collected 4 July 2024 (test and main)

# (there were 5 before with differnet data structure, needing different preprocessing, they are also brought in here)
# Then saves big data df, and also that data split out into the three probability groups

library(tidyverse)
library(here)
library(rjson)
library(here)

# ---------- Get main data -----------
# Get individual csvs into a list
csvList <- lapply(list.files(here("Data", "batch"), full.names = TRUE), 
                  read.csv, stringsAsFactors = F)

# Bind them into a dataset
dataset <- do.call(rbind, csvList)

# Data rows were generated by different trials, but we can get everything we need in one row
# But first we need to replace spaces with NA
dataset <- dataset |> 
  mutate(across(c('answer'), ~na_if(.,"")))

# Then can fill upwards to get the text answer in the same place as the trial info
dataset <- dataset |> 
  fill(answer, .direction = 'up')

# ---------- Get jsons of static worlds info used in experiment ------
# Get the jsons
worlds <- fromJSON(file = here("Experiment", "worlds.json"))
conds <- fromJSON(file = here("Experiment", "conds.json"))

worldsdf <- as.data.frame(worlds) # 8 obs of 132 vars
condsdf <- as.data.frame(conds) # 2 obs of 21 vars 

# ------------ Get pilot data -------------

csvList <- lapply(list.files(here("Data", "PilotData"), full.names = TRUE), 
                  read.csv, stringsAsFactors = FALSE)

# bind them 
dataset2 <- do.call(rbind, csvList) # 250 of 20

# Data rows were generated by different trials, but we can get everything we need in one row
# But first we need to replace spaces with NA
dataset2 <- dataset2 |> 
  mutate(across(c('answer'), ~na_if(.,"")))

# Then can fill upwards to get the text answer in the same place as the trial info
dataset2 <- dataset2 |> 
  fill(answer, .direction = 'up')

# Put batch and pilot together
dataset <- rbind(dataset,dataset2)

# ---------- Now analysing all data together ---------
# 6950 obs of 15

# Remove empty cols and rows
dataset <- dataset |> filter(cb!='NA') # Obs should be 12* no. of ppts, as each did 12 trials. 3509 of 13


# Here 3329 of 13 vars, so some did not complete. Find who is complete
s12 <- dataset |> 
  group_by(prolific_id) |> 
  summarise(n=n()) # 294
keep <- filter(s12,n==12) # 279
dataset <- dataset |> filter(prolific_id %in% keep$prolific_id) # 3348

# NOW can remove the cols with long strings, and rbind with the pilot2 data (which we checked was complete at the time)
dataset <- dataset |> select(-c(2:4,6,7))
dataset <- dataset |> select(-c(13:14))

#dataset <- rbind(dataset, pilot5) # no - decided the very first pilot is too differnet to use

# Put a column with structure - for some reason it doesn't have
data <- dataset |> 
  mutate(structure = if_else(grepl("^c", trialtype), 'conjunctive', 'disjunctive'))


# --------------- Processing the answers participants gave -----------------

# Now reattach the number of their answer, as atm it has only recorded the text on their radio button
# First here are the arrays of possible buttons from js exp.
jobanswers <- c('The candidate had skill A',
            'The candidate did not have skill A',
            'The candidate demonstrated skill A',
            'The candidate did not demonstrate skill A',
            'The candidate had skill B',
            'The candidate did not have skill B',
            'The candidate demonstrated skill B',
            'The candidate did not demonstrate skill B')

cookanswers <- c('The chef completed the main dish',
                 'The chef did not complete the main dish',
                 'The main dish impressed the panel',
                 'The main dish did not impress the panel',
                 'The chef completed the dessert',
                 'The chef did not complete the dessert',
                 'The dessert impressed the panel',
                 'The dessert did not impress the panel')

groupanswers <- c('The lecturer attended',
                  'The lecturer did not attend',
                  'The lecturer talked about the paper',
                  'The lecturer did not talk about the paper',
                  'The postdoc attended',
                  'The postdoc did not attend',
                  'The postdoc talked about the paper',
                  'The postdoc did not talk about the paper')

# Now make a new column with the position in array of their answer
data <- data |> 
  mutate(ans = if_else(scenario=='job', match(data$answer, jobanswers), 
                                    if_else(scenario=='cook', match(data$answer, cookanswers),
                                            match(data$answer, groupanswers))))


# There is one(!) cell in the data that stubbornly keep putting NA, even though I can see a legal answer in the original data
# No idea why. I am replacing manually 
data[2861,15] <- 4


# ------------ The long road to reversing the counterbalancing -------------------

# There was a mistake with some incomplete counterbalancing. The result is some participants effectively saw an equivalent trialtype, with A and B on the other side

# To solve, first split the data. cb0 is fine the way it is, and cb1 needs some trials to be flipped
data0 <- data |> filter(cb==0)
data1 <- data |> filter(cb==1)

# For TRIALTYPE c1,c4, c5, d1, d6, d7, we can just switch the answers
# But for the others they have to be changed as follows:
# c2 goes to c3
# c3 goes to c2
# d2 goes to d4
# d3 goes to d5
# d4 goes to d2
# d5 goes to d3

# To do this, we'll take an intermediate column and then start replacing values
data1$cbtt <- data1$trialtype
data1$cbtt[data1$trialtype=='c2'] <- 'c3'
data1$cbtt[data1$trialtype=='c3'] <- 'c2'
data1$cbtt[data1$trialtype=='d2'] <- 'd4'
data1$cbtt[data1$trialtype=='d3'] <- 'd5'
data1$cbtt[data1$trialtype=='d4'] <- 'd2'
data1$cbtt[data1$trialtype=='d5'] <- 'd3'

# That flipped the trial, but then their answers also need to be flipped! 
# Otherwise the probabilities and answers don't make sense. 
# The 8 possible answers followed a pattern: A0,1 Au0,1 then same for B. So 1,5; 2,6; 3,7; 4,8 

# Flip the numerical indices of answers about the middle
# Store indices of which answers already relate to Var A and which to Var B
aans <- as.vector(1:4) # A
bans <- as.vector(5:8) # B

# Create new var where they are flipped, then reassign
data1$intans <- data1$ans 

data1 <- data1 |> 
  mutate(anscb = if_else(ans %in% aans, intans+4, intans-4))
data1 <- data1 |> 
  select(-c(trialtype,ans)) |> rename(trialtype = cbtt, ans = anscb)

# Now rearrange the cols we need. [Later found this is step not needed and gets repeated in the plotting to put everything back in. When I have time I will change it to here]
data1 <- data1 |> 
  select(1:6,13,14,16)
data0 <- data0 |> 
  select(1:6,14,13,15)

data <- rbind(data0,data1) # 3456 of 9
# Phew think it's ok now

# Now map the answers they gave to the actual variable values, in three increasing levels of granularity
# 1. Just the 4 variables, irrespective of the value they took
data <- data |> 
  mutate(ansVar = if_else(ans==1|ans==2, 'A', 
                                         if_else(ans==3|ans==4, 'Au',
                                                 if_else(ans==5|ans==6, 'B', 'Bu'))))

# 2. Six values, ie A and B are observed so don't need options, but unobserved Au and Bu can take either value
data <- data |> 
  mutate(ansVar2 = if_else(ans==1|ans==2, 'A', 
                                          if_else(ans==3, 'Au=1',
                                                  if_else(ans==4, 'Au=0',
                                                          if_else(ans==5|ans==6, 'B', 
                                                                  if_else(ans==7, 'Bu=1', 'Bu=0'))))))
# 3. Eight values: each var can take either value
data <- data |> 
  mutate(ansVar3 = if_else(ans==1, 'A=1',
                                          if_else(ans==2, 'A=0',
                                                  if_else(ans==3, 'Au=1',
                                                          if_else(ans==4, 'Au=0',
                                                                  if_else(ans==5, 'B=1', 
                                                                          if_else(ans==6, 'B=0',
                                                                                  if_else(ans==7, 'Bu=1', 'Bu=0'))))))))



# -------- Permissable actual cause analysis -----------
# Checks whether ppt's answers are permissable as per Tadeg's (via Halpern) actual causation condition
# NOTE: the var "possAns" is indexed 1:8 and was stored in worlds only for this, not for any use in javascript

# Get .possAns out of json 
js <- worldsdf |> 
  select(ends_with("possAns"))

# Remove .possAns string from colnames, transpose so easier to search and add 1 to every cell because js indexes from 0
colnames(js) <- sub(".possAns", "", colnames(js))
js <- t(js)

# Empty vec to put the answers in, same order and size as
isPerm <- rep(NA, 3348) # 

# (Long winded index match - would be good to know a better way)
for (k in 1:nrow(data)) 
{
  row <- data[k,]
  ttype <- row$trialtype
  ans <- row$ans
  jsvec <- js[ttype,1:8]
  isposs <- ans %in% jsvec
  isPerm[k] <- isposs
}
# Add to df1 (I checked it is right)
data <- cbind(data, isPerm)

# Now group by ppt to see if they mostly pick permissable answers. groupby subjectID first to see who is at it
tf <- data |> 
  group_by(isPerm) |> 
  summarise(n=n()) # They do

# -------- Coherent cause analysis ----------- ENDED UP NOT USING THESE VARIABLES 
# Checks whether ppt's answers are COHERENT in context of that situation
# A less stringent version of the previous analysis
# NOTE: the var "cohAns" is indexed 1:8 and was stored in worlds only for this, not for any use in javascript

# Get .cohAns out of json
jc <- worldsdf |> select(ends_with("cohAns"))

# Remove .cohAns string from colnames, transpose so easier to search
colnames(jc) <- sub(".cohAns", "", colnames(jc))
jc <- t(jc)

# Empty vec to put the answers in, same order and size as
isCoh <- rep(NA, 3348) 

# (Long winded index match - would be good to know a better way)
for (k in 1:nrow(data))
{
  row <- data[k,]
  ttype <- row$trialtype
  ans <- row$ans
  jsvec <- jc[ttype,1:8]
  iscoh <- ans %in% jsvec
  isCoh[k] <- iscoh
}
# Add to df1 (I checked it is right)
data <- cbind(data, isCoh)

# Now group by ppt to see if they mostly pick permissable answers. Groupby subject id to see who is at it
tc <- data |> 
  group_by(isCoh) |> 
  summarise(n=n()) # They do


# ------------ Assign some new variables: pgroup then latent variables
# We now give a variable for probgroup, and then split the data into wee dfs for each one, a controversial decision that may backfire and get changed later
data <- data |> 
  mutate(pgroup = if_else(prob0=='10%' & prob1=='50%' | prob2=='10%' & prob3=='50%', '1', 
                                         if_else(prob0=='50%' & prob1=='80%' | prob2=='50%' & prob3=='80%', '2', '3')))


# How often did they select latent variables?
data <- data |> 
  mutate(isLat = ifelse(ansVar=='Au'|ansVar=='Bu', TRUE, FALSE))

# Now encode those rules by putting FALSE. (Everything else is already correctly determined)
data$realLat <- data$isLat
data$realLat[data$trialtype=='c5'|data$trialtype=='d6'] <- FALSE
data$realLat[data$trialtype=='d2' & data$ansVar=='Bu'] <- FALSE
data$realLat[data$trialtype=='d3' & data$ansVar=='Bu'] <- FALSE
data$realLat[data$trialtype=='d4' & data$ansVar=='Au'] <- FALSE
data$realLat[data$trialtype=='d5' & data$ansVar=='Au'] <- FALSE

# We also want a variable denoting 'connected with var A' (including A and Au) and likewise for B
data <- data |> 
  mutate(connectedWith = ifelse(ansVar=='A'|ansVar=='Au', 'A', 'B'))

data <- data |> 
  rename(node3 = ansVar3)


save(data, file = here("Data", "Data.Rdata"))
