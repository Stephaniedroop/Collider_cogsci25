###########################################################################
################### GW - general CESM functions ###########################

# Functions to run counterfactual simulation and assign a quantity of responsibility to each of several causes.
# 1) function that calculates all possible observations of the causes ('worlds') and gets conditional probabilities and posterior
# Needs inputs of:
# -- cause variables, assuming these happen either 0,1 and their strengths, assuming in a vector of prob 0, prob 1
# -- causal structure, whether disjunctive or conjunctive

# 2) function to get counterfactuals and effect size:
# -- simulates counterfactuals by resampling from the prior for vars with p=1-s where s=stability to real world.
# -- prints out correlation of effect with each causal variable across these simulated counterfactual worlds.

# 'N' stands for NEW: the old file had a direct dependency function and two parameters for model prediction, stability and sensitivity.
# In Jan25 we decided to restrict to stab0.7 and sens1 (ie no sens). So reran. 
# Also need to expand f2 to allow all combinations, for a later model lesion

# ------------- Create world combos df ----------------- 
# A function to get all world combinations

# Gives varying obs: if c then 5 x 4, if d then 7 x 4 (reason is we need all combos of unobs, even incoherent, for lesion later)
world_combos3 <- function(params, structure) { 
  causes2 <- rownames(params)
  n_causes <- nrow(params)
  #causes <- rownames(params)
  # Make a df of all combinations of variable settings
  df <- expand.grid(rep(list(c(0,1)),n_causes), KEEP.OUT.ATTRS = F)
  # ... with variables as the column names
  colnames(df) <- c(causes2)
  worlds <- nrow(df)
  # Calculate EFFECT (E) depending on whether structure is disjunctive or conjunctive
  if (structure=="conjunctive") { 
    df$E <- as.numeric((df[1] & df[2]) & (df[3] & df[4])) 
  }
  if (structure=="disjunctive") { 
    df$E <- as.numeric((df[1] & df[2]) | (df[3] & df[4])) 
  }
  mat <- as.matrix(df[,1:4])
  # Replace every cell with the relevant indexed edge strength from params
  for (k in 1:worlds){
    for (cause in causes2) {
      a <- params[cause,df[k,cause]+1] # It needs the '+1' because r indexes from 1 not 0
      mat[k,cause] <- a 
    }
  }
  colnames(df)[1:4] <- causes1 #c('A', 'Au', 'B', 'Bu')
  df <- cbind(df, mat)
  # For each row of df, the parameter is now the product of the same row of the intermediate mat
  df$Pr <- apply(mat, 1, prod) # This is how likely that setting of causes is. Sums to 1
  df$PrUn <- df$peA*df$peB
  df$index <- 1:nrow(df)
  df$structure <- structure 
  
  # This chunk gives all combinations of Au and Bu to all the real sets of ABE. 
  # (We need all combinations, even those with 0 posterior, because later a lesion samples by prior instead)
  result <- df %>% group_by(A, B, E) %>%
    group_split() %>%
    lapply(function(group) {
      combinations <- expand.grid(Au = c(0,1), Bu=c(0,1))
      cbind(group[1, c("A", "B", "E")], combinations)
    }) %>%
    bind_rows()
  
  # Then we want to merge this back in to the df
  test <- merge(x = result, y = df, by = c('A','B','Au','Bu'))
  
  # Calculate posterior. Some are incoherent but will be removed later
  df1 <- test %>% 
    group_by(A, B, E.y, E.x) %>% 
    mutate(posterior = PrUn/sum(PrUn)) %>%  #groupPost = cur_group_id()
    ungroup() 
  
  # Now set the impossible ones to 0
  df1$posterior[df1$E.x!=df1$E.y] <- 0 

  df1 <- df1 %>% 
    group_by(A, B, E.x) %>% 
    mutate(groupPost = cur_group_id()) %>% 
    ungroup() 
  
  df1
  # Kept this just in case we still need to give a group id
  #df <- df %>% group_by(A, B, E, .drop=F) #%>% mutate(groupPost = cur_group_id(), posterior = PrUn/sum(PrUn)) %>% ungroup() 
} # Makes it of 16 vars


# Notes on realLatent
# Sometimes the values of the unobserved variables can be inferred logically. These are NOT 'realLatent'.
# realLatent is when we genuinely don't know what values the unobserved variables take. (when poss >1 in the function `get_cond_probs`)
# It affects the following situations (easier to point out when it is NOT realLatent, and take the inverse)
# All are realLatent, except:
# c5: Au and Bu
# d2: Bu
# d3: Bu
# d4: Au
# d5: Au
# d6L Au and Bu

# ------------- CESM FUNCTION ----------------------------
# A function to run the generic minimal CESM. Takes arguments of:
# - params that lists the base rates and strengths of exog noise u vars
# - a df of all the world combos with probs, generated by function world_combos
# (some redundancy across these two functions but probably ok)

# This used to be big function generic_cesm 
get_cfs <- function(params, structure, df) { 
  
  n_causes <- nrow(params)
  #causes <- rownames(params)
  #structure <- structure
  p <- params[,2] # The p_eachvar==1 
  pvec <- rep(p, times = N_cf) # Turn it into a 40k vec
  #p_vec_prime <- (1-sens)*rep(.5, length(pvec)) + sens * pvec
  mp <- df 
  # Add new columns then fill them
  new_cols <- c('mA', 'mAu', 'mB', 'mBu', 'cfsA', 'cfaAu', 'cfsB', 'cfsBu', 'Sum')
  mp[new_cols] <- NA
  worlds <- nrow(df) #as.integer(nrow(df)/2)
  
  # Loop through 16 possible world settings
  for (c_ix in 1:worlds)
  {
    # STABILITY: Generate vector of random numbers. The ones outside stability s are to be resampled. Put T for them
    resample <- runif(n_causes*N_cf) > s # 40k vec, with T for ones higher than the stability param 
    # Take the current case
    case <- df[c_ix,] # one obs of 8 - the real world. No, 18
    # Repeat the cause settings of the current world 10000 times
    cf_csrep <- rep(as.numeric(case[1:n_causes]), times = N_cf) # 40k vec
    # Now resample from its prior each value whose place in resample was set to TRUE in stability step
    cf_csrep[resample] <- runif(sum(resample)) < pvec[resample] 
    # Express these generated counterfactuals in tabular form again
    cfs <- data.frame(matrix(cf_csrep, nrow = N_cf, byrow = T))
    colnames(cfs) <- causes1
    
    # Calculate effect (determinative)
    if (structure=="conjunctive") { 
      cfs$E <- as.numeric((cfs[1] & cfs[2]) & (cfs[3] & cfs[4])) 
    }
    if (structure=="disjunctive") { 
      cfs$E <- as.numeric((cfs[1] & cfs[2]) | (cfs[3] & cfs[4])) 
    }
   
    # Add column T/F for the ones that match
    cfs$Match <- cfs$E==case$E.x
    
    cor_sizes <- rep(NA, n_causes)
    realcfs <- rep(NA, n_causes)
    for (cause in 1:n_causes)
    {
      # the second part sets correlation negative when cause pushes against effect taking state it took
      cor_sizes[cause] <- cor(cfs[[causes1[cause]]], cfs$Match) * (c(-1,1)[as.numeric(case[[causes1[cause]]])+1])
      realcfs[cause] <- sum(cfs[[causes1[cause]]]!=case[[causes1[cause]]])
    }
    mp[c_ix, 18:21] <- t(cor_sizes)
    mp[c_ix, 22:25] <- t(realcfs)
    mp[c_ix, 26] <- sum(cfs$E==case$E.x)
    mp$index <- 1:nrow(mp)
  }
  mp
}
  