## ----setup, include=FALSE---------------------------------------------------------------------------------------
knitr::opts_chunk$set(echo = TRUE)


## ----include=FALSE----------------------------------------------------------------------------------------------
library(tidyverse)
rm(list=ls())
df <- read.csv('../Model_data/modelAndDataUnfit.csv') # 288 obs of 14

# Let's create variables coding the actual observation
df.map<-data.frame(condition=c('c1','c2','c3','c4','c5','d1','d2','d3','d4','d5','d6','d7'),
                   A=c(0,0,1,1,1, 0,0,0,1,1,1,1),
                   B=c(0,1,0,1,1, 0,1,1,0,0,1,1),
                   E=c(0,0,0,0,1, 0,0,1,0,1,0,1))

for (i in 1:nrow(df))
{
  df$A[i]<-df.map$A[df.map$condition==df$trialtype[i]]
  df$B[i]<-df.map$B[df.map$condition==df$trialtype[i]]
  df$E[i]<-df.map$E[df.map$condition==df$trialtype[i]]
}

# Allocate Boolean status for Include: F for noisy or nonsense answers (e.g. answering A=0 when they can see A=1). This is only for the cogsci paper, to handle 1.4% of data. later we handle it with a noise parameter epsilon
df <- df %>% 
  mutate(include = !( (node3=='B=0' & B==1) | (node3=='B=1' & B==0) | (node3=='A=0' & A==1) | (node3=='A=1' & A==0)))



## ----include=FALSE----------------------------------------------------------------------------------------------
#For testing:
par <- 1
mod_name <- 'full'
i <- 1

model_likelihood <- function(par, df, mod_name)
{
  
  tau <- exp(par) 
  tt <- unique(df$trial_id) # unique trial ids
  # Empty place for NLLs
  nlls <- rep(NA, length(tt)) 
  for (i in 1:length(tt))
  {
    n <- df$n[df$trial_id==tt[i] & df$include==T] #get counts
    mod_raw <- df[[mod_name]][df$trial_id==tt[i] & df$include==T] #get model predictions
    mod_raw[is.na(mod_raw)] <- 0 
    # Softmax with tau only
    mod_pred2 <- exp(mod_raw/tau)/sum(exp(mod_raw/tau)) 
    # Get likelihood for this trial
    nlls[i] <-  -sum(log(mod_pred2)*n) 
  }
  sum(nlls)#return the total likelihood
}


## ----include=FALSE----------------------------------------------------------------------------------------------
generate_predictions <- function(mod_name, tau, df) {
  tt <- unique(df$trial_id)
  do.call(rbind, lapply(tt, function(t_id) {
    trial_rows <- df$trial_id == t_id & df$include == TRUE
    mod_raw <- df[[mod_name]][trial_rows]
    mod_raw[is.na(mod_raw)] <- 0
    
    mod_pred2 <- exp(mod_raw/tau)/sum(exp(mod_raw/tau))
    
    data.frame(
      model = mod_name,
      trial_id = t_id,
      node3 = df$node3[trial_rows],
      predicted_prob = mod_pred2
    )
  }))
}


## ----include=FALSE----------------------------------------------------------------------------------------------

optimize_models <- function(model_names, df, initial_values = 1) { 
  optimize_single <- function(mod_name) {
    result <- tryCatch({
      optim(par = initial_values, 
          fn = model_likelihood, 
          method = 'Brent', 
          lower=-10, upper=100,
          df = df, 
          mod_name = mod_name)
  }, error = function(e) {
      message("Error in optimization for model ", mod_name, ": ", e$message)
      return(list(par = NA, value = NA))
    })
    return(result)
  }
  
  out <- lapply(model_names, optimize_single)
  names(out) <- model_names
  
  mfs <- data.frame(
    model = names(out),
    tau = exp(sapply(out, function(x) x$par)),
    logl = -sapply(out, function(x) x$value)
  ) %>%
    mutate(BIC = -2 * logl + 1 * log(sum(df$n[df$include == TRUE]))) 
  
  # Generate predictions 
  predictions <- do.call(rbind, lapply(names(out), function(mod_name) {
    if(!any(is.na(out[[mod_name]]$par))) {
      generate_predictions(
        mod_name = mod_name,
        tau = exp(out[[mod_name]]$par),
        df = df
      )
    }
  }))
  
  list(
    model_fits = mfs %>% mutate(tau = format(tau, digits=3)),
    predictions = predictions
  )
}


# Usage:
model_names <- c('full', 
                 'noAct', 
                 'noInf', 
                 'noSelect', 
                 'noActnoInf', 
                 'noActnoSelect', 
                 'noInfnoSelect', 
                 'noActnoInfnoSelect')  

results <- optimize_models(model_names, df)

print(results)
newdf <- results$predictions # 1728 obs of 4


## ---------------------------------------------------------------------------------------------------------------
df_wide <- newdf %>%
  pivot_wider(
    id_cols = c(trial_id, node3),
    names_from = model,
    values_from = predicted_prob
  )



## ---------------------------------------------------------------------------------------------------------------
justppt <- df %>% select(trial_id, node3, n, prop, pgroup, Actual, A, B, E, include)

fitforplot <- merge(df_wide, justppt, by = c('trial_id', 'node3'))


## ---------------------------------------------------------------------------------------------------------------
write.csv(fitforplot, 'fitforplot.csv')  

